@model TrendViewModel
@{
    ViewData["Title"] = $"Trend: {Model.Term}";
}

@if (Model.MaxCount == 0)
{
    <h3>No data in series</h3>
    <p>There were no stories containing the term '@Model.Term' in the data series.</p>
}
else
{
    <h3>Data for '@Model.Term'</h3>
    <div class="remark">Search term is case insensitive.</div>
    <p>This shows the count of stories posted to Hacker News featuring the search term in the title by <span id="period">Day</span>.</p>
    <p>The data is not updated in real time. Currently the data runs between <em>@Model.From.ToShortDateString()</em> and <em>@Model.To.ToShortDateString()</em>.</p>

    <input id="data-load" type="hidden" asp-for="Data" />

    <label for="period-selector" style="display: inline-block; margin-right: 25px;">
        Group Data By:
        <select id="period-selector" onchange="periodSelectorChanged()" style="width: 200px; margin-left: 25px; height: 36px;">
            <option label="Day">Day</option>
            <option label="Week">Week</option>
            <option label="Month" selected>Month</option>
        </select>
    </label>

    <button type="button" id="percent" onclick="togglePercent()">Display as % of stories</button>

    <div id="plot"></div>

    <div id="add-term-container" class="u-pull-right">
        <input name="text" type="text" id="text" title="Add another search term to compare trends" />
        <button id="add-term" type="button" title="Add this search term to the plot">Add</button>
        <label for="allwords" id="allwords-label" title="Title must contain all words.">
            Search result must match all words: 
            <input type="checkbox" name="allwords" id="allwords" value="true" checked />
        </label>
    </div>
}


@section Scripts {
    <script>
        var categories = ["Day", "Week", "Month"];

        function addDays(date, days) {
            var result = new Date(date);
            result.setDate(result.getDate() + days);
            return result;
        }

        function loadDataFromHiddenInput() {
            var str = $("#data-load").val();
            var json = JSON.parse(str);
            var start = moment(json.Start);

            var dates = [];

            for (var i = 0; i < json.Counts.length; i++) {
                dates.push(start.toDate());
                start.add(1, 'd');
            }

            json.Dates = dates;

            return json;
        }

        function buildXAxis(data, period) {
            var last = data.x[data.x.length - 1];
            var max = period !== "Day"
                ? last
                : addDays(Date.parse(last), 1);

            return {
                range: [data.x[0], max],
                type: 'date',
                linecolor: '#333',
                linewidth: 1,
                title: period
            };
        }

        function buildYAxis(data, isCount) {
            var maxBySeries = isCount
                ? data.ys.map(series => Math.max.apply(Math, series))
                : data.percents.map(series => Math.max.apply(Math, series));
            var max = Math.max.apply(Math, maxBySeries);
            return {
                range: [0, isCount ? (max + 1) : max + 0.1],
                linecolor: '#333',
                linewidth: 1,
                title: isCount ? '# of stories' : '% of total stories'
            };
        }

        function getPlotlyLayout(data, isCount, period) {
            return {
                xaxis: buildXAxis(data, period),
                yaxis: buildYAxis(data, isCount),
                title: 'Posts over time for \'@Model.Term\'.',
                hovermode: 'closest'
            };
        }

        function getModeBarSettings() {
            return {
                modeBarButtonsToRemove: ['pan2d', 'lasso2d', 'autoScale2d', 'toggleSpikelines', 'select2d']
            };
        }

        function dataForPeriod(data, others, period) {
            var dateLabels = [];
            var counts = [[]];
            var percents = [[]];
            var names = [data.Term];

            others.forEach(x => {
                counts.push([]);
                percents.push([]);
                names.push(x.term + (x.allWords ? '' : ' (any)'));
            });

            var previous;

            data.Dates.forEach((x, i) => {
                switch (period) {
                case "Week":
                    groupDataPointsByPeriod(data,
                        x,
                        i,
                        dateLabels,
                        others,
                        counts,
                        percents,
                        previous,
                        x => moment(x).endOf('week').toDate());
                    previous = x;
                    break;
                case "Month":
                    groupDataPointsByPeriod(data,
                        x,
                        i,
                        dateLabels,
                        others,
                        counts,
                        percents,
                        previous,
                        x => moment(x).startOf('month').toDate());
                    previous = x;
                    break;
                case "Day":
                default:
                    dateLabels.push(x);

                    counts[0].push(data.Counts[i]);
                    percents[0].push((data.Counts[i] / data.DailyTotals[i]) * 100);
                    others.forEach((o, oi) => {
                        counts[oi + 1].push(o.counts[i]);
                        percents[oi + 1].push(((o.counts[i] / data.DailyTotals[i]) * 100).toFixed(2));
                    });
                    break;
                }
            });

            if (period !== "Day") {
                counts.forEach((set, setIndex) => {
                    var percentData = percents[setIndex];
                    set.forEach((x, i) => {
                        if (percentData[i] !== 0) {
                            percentData[i] = ((x / percentData[i]) * 100).toFixed(2);
                        }
                    });
                });
            }

            return {
                ys: counts,
                percents: percents,
                x: dateLabels,
                names: names
            };
        }

        function groupDataPointsByPeriod(data,
            date,
            index,
            dateLabels,
            others,
            counts,
            percents,
            previous,
            periodGrouper) {
            var dayCount = data.Counts[index];
            var dayTotal = data.DailyTotals[index];

            var isNewPeriod = false;
            var periodForThisDate = periodGrouper(date);

            if (index === 0) {
                dateLabels.push(periodForThisDate);
                isNewPeriod = true;
            } else {
                var periodForPreviousDate = periodGrouper(previous);

                if (periodForThisDate.toDateString() === periodForPreviousDate.toDateString()) {
                } else {
                    dateLabels.push(periodForThisDate);
                    isNewPeriod = true;
                }
            }

            if (isNewPeriod) {
                counts[0].push(dayCount);
                percents[0].push(dayTotal);
                others.forEach((o, oi) => {
                    counts[oi + 1].push(o.counts[index]);
                    percents[oi + 1].push(dayTotal);
                });
            } else {
                var periodIndex = counts[0].length - 1;
                counts[0][periodIndex] += dayCount;
                percents[0][periodIndex] += dayTotal;
                others.forEach((o, oi) => {
                    counts[oi + 1][periodIndex] += o.counts[index];
                    percents[oi + 1][periodIndex] += dayTotal;
                });
            }
        }

        function getPlotlyData(data, isCount, period) {
            var isMonthly = period === "Month";
            var width = !isMonthly ? 1 : data.ys.length === 1 ? 2 : 1;
            return data.ys.map((ySeries, i) => {
                return {
                    x: data.x,
                    y: isCount ? ySeries : data.percents[i],
                    type: 'scatter',
                    mode: period !== "Day" ? 'lines' : 'markers',
                    marker: {
                        size: 3
                    },
                    line: {
                        width: width
                    },
                    name: data.names[i]
                }
            });
        }

        function getPlotlyElement() {
            return document.getElementById('plot');
        }

        function periodSelectorChanged() {
            var period = $("#period-selector").val();

            if (categories.indexOf(period) < 0) {
                return;
            }

            togglePeriod(period);
        }

        function togglePeriod(period) {
            document.hntrendstore.CurrentCategory = period;

            $("#period").text(period);

            var isCount = document.hntrendstore.isCount;
            var data = dataForPeriod(loadDataFromHiddenInput(),
                document.hntrendstore.others,
                document.hntrendstore.CurrentCategory);
            Plotly.newPlot(getPlotlyElement(),
                getPlotlyData(data, isCount, document.hntrendstore.CurrentCategory),
                getPlotlyLayout(data, isCount, document.hntrendstore.CurrentCategory),
                getModeBarSettings());
        }

        function togglePercent() {
            var current = document.hntrendstore.isCount;
            var isCount = !current;

            $('#percent').text(isCount ? 'Display as % of total stories' : 'Display as # of stories');
            document.hntrendstore.isCount = isCount;
            var data = dataForPeriod(loadDataFromHiddenInput(),
                document.hntrendstore.others,
                document.hntrendstore.CurrentCategory);
            Plotly.newPlot(getPlotlyElement(),
                getPlotlyData(data, isCount, document.hntrendstore.CurrentCategory),
                getPlotlyLayout(data, isCount, document.hntrendstore.CurrentCategory),
                getModeBarSettings());
        }

        function addDataPlot(data) {
            document.hntrendstore.others.push(data);
            togglePeriod(document.hntrendstore.CurrentCategory);
        }

        $("#add-term").click(() => {
            var term = $("#text").val().trim();

            if (term.length < 1) {
                $("#text").val('');
                return;
            }

            var allWords = $("#allwords").prop('checked');

            var hasExisting = document.hntrendstore.others.filter(x => x.term.toUpperCase() === term.toUpperCase()
            && x.allWords === allWords)
                .length >
                0;

            if (hasExisting) {
                alert(`Search term ${term} already displayed.`);
                return;
            }

            $.get(`/api/plot/${term}?allWords=${allWords}`)
                .done(data => {
                    $("#text").val('');
                    addDataPlot(data);
                })
                .fail(err => console.log(err));
        });

        $("#text").keyup(event => {
            if (event.keyCode === 13) {
                $("#add-term").click();
            }
        });

        $(function() {

            document.hntrendstore = {
                isCount: true,
                CurrentCategory: "Month",
                others: []
            };

            if (!$('#data-load').length) {
                return;
            }

            $("#period").text(document.hntrendstore.CurrentCategory);


            var json = loadDataFromHiddenInput();

            var data = dataForPeriod(json, [], document.hntrendstore.CurrentCategory);

            Plotly.plot(getPlotlyElement(),
                getPlotlyData(data, true, document.hntrendstore.CurrentCategory),
                getPlotlyLayout(data, true, document.hntrendstore.CurrentCategory),
                getModeBarSettings());
        });
    </script>
}